#include <iostream>
#include <cmath>
#include <numbers>
#include <random>
#include <complex>

#include "vector.h"
#include "matrix.h"
#include "nonLinear.h"
#include "eigen.h"

double f(double x) {
    return (std::pow(x, 9) + std::numbers::pi)
        * cos(log(std::pow(x, 2) + 1)) /
        std::pow(std::numbers::e, std::pow(x, 2)) - x / 2022;
}

double df(double x) {
    return -2 * std::pow(std::numbers::e, -std::pow(x, 2)) * (std::pow(x, 9) + std::numbers::pi)
           * x * sin(log(std::pow(x, 2) + 1)) / (std::pow(x, 2) + 1)

           -2 * std::pow(std::numbers::e, -std::pow(x, 2)) * (std::pow(x, 9) + std::numbers::pi) * x
            * cos(log(std::pow(x, 2) + 1))

           +9 * std::pow(std::numbers::e, -std::pow(x, 2))
              * std::pow(x, 8) * cos(log(std::pow(x, 2) + 1)) - 1.0/2022;

}

int main() {
    /*auto roots = NonLinear(f, -10, 10).solve();
    for (auto v : roots) {
        std::cout << v << std::endl;
    }*/

    /*std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distr(-2, 5);
    Matrix a = Matrix(10, data);
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            a(i, j) = distr(gen);
        }
    }
    std::cout << a << std::endl;*/

    Matrix m1{{1,-2,1,0,-1,1,-2,2,0,-2},
              {0,2,0,0,2,1,-1,-1,-1,-2},
              {0,1,0,-1,1,-1,0,-1,1,-1},
              {-2,-1,2,-1,0,0,0,0,1,0},
              {1,-2,0,1,0,-2,-1,0,2,2},
              {-2,-2,0,-2,0,1,1,-2,1,1},
              {-1,-2,-1,-1,-2,-1,-2,1,-1,2},
              {-2,1,2,-2,0,2,1,-1,-2,2},
              {0,1,0,1,1,-2,2,0,1,1},
              {0,0,2,-1,-1,0,-2,2,-1,-1}};

    Matrix m2{{ -1, 1, -1, 0, -1, 0, -1, 1, 1, -1, 0, -1, -1, 1, 0, 0, 1, 1, 1, 1 },
            { -1, 0, -1, 1, -1, 0, 0, 0, 0, -1, 0, 0, -1, 1, 0, -1, 1, -1, -1, 0 },
            { 1, 0, -1, 1, 0, 1, -1, -1, -1, 0, -1, -1, 1, -1, 1, 1, -1, 1, -1, 0 },
            { -1, 1, 0, 0, -1, 0, 0, -1, 0, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 0 },
            { 1, 0, -1, 0, 0, -1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, -1, 0, 0, 1 },
            { 0, 0, 0, 0, -1, 1, 1, 0, 0, 1, 1, 0, -1, 0, 1, 1, 0, 1, 0, 0 },
            { -1, 0, 1, 1, 1, -1, -1, 0, -1, 1, -1, -1, -1, 0, -1, 0, 0, 0, -1, 1 },
            { 0, 0, -1, -1, 0, 1, 1, 1, 1, -1, 0, 0, -1, 1, 1, 1, 1, 0, 0, -1 },
            { 0, 0, 1, 1, 0, 1, 1, 0, 1, -1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1 },
            { 0, -1, 0, 0, 1, 0, -1, 0, -1, 0, -1, 0, -1, 0, 1, -1, 0, 0, 1, 1 },
            { 1, -1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 1, -1, 0, 1, 1, 1, 0, 0, 0 },
            { 0, 1, 0, 0, -1, 0, 1, 0, 1, 0, 0, 1, 1, -1, -1, 0, -1, 1, 1, -1 },
            { -1, -1, -1, -1, 0, 1, -1, 0, 0, -1, 0, 0, 0, 1, 1, 0, 0, 0, -1, 0 },
            { -1, 0, 1, 0, -1, 0, 0, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 0 },
            { 1, -1, 0, -1, -1, 0, -1, -1, 0, 0, 1, 0, 1, 1, -1, 1, 0, 0, -1, 0 },
            { -1, -1, 1, 0, -1, 1, 1, -1, 1, 0, 0, -1, 1, -1, -1, 0, 0, 1, 1, 1 },
            { 0, 0, -1, 0, 0, 0, 0, -1, 1, 1, 0, -1, 1, -1, 0, 0, 0, -1, -1, 1 },
            { -1, 0, -1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, -1, 1, 1, 0, -1, 0, -1 },
            { -1, 0, 1, 0, 0, 0, 0, -1, 1, -1, 1, -1, 0, -1, -1, 1, 0, 1, 0, 0 },
            { 0, -1, -1, 1, -1, 1, -1, -1, -1, 1, 1, -1, 0, -1, -1, 0, 1, 0, -1, -1 } };
    //std::cout << m1 << std::endl;

    Matrix test{ {18, -8, -20}, {20, -10, -20}, {8, -8, -10} };
    //std::cout << m1 << std::endl;

    Vector r1(10, 1);
    Vector r2(20, 1);
    std::cout << r1 << std::endl;

    Eigen eigenvv = Eigen::powerIteration(m1, r1, 10e-8);
    std::cout << eigenvv << std::endl;


    return 0;
}
